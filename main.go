package main

import (
	"context"
	"crypto/x509"
	_ "embed"
	"encoding/base64"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"github.com/google/uuid"
	"github.com/sky93/aaguid-information-generator/internal"
	"go/format"
	"io"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"reflect"
	"sort"
	"strings"
)

// -----------------------------------------------------------------------------
// Embedded File Content
// -----------------------------------------------------------------------------

// generatedByComment is the boilerplate comment marking auto-generated files.
var generatedByComment = "// Code generated by aaguid-information-generator.; DO NOT EDIT."

//go:embed internal/types.go
var typesStr string

// typesFileContent includes the above generatedByComment plus the embedded content of types.go.
var typesFileContent = fmt.Sprintf("%s\n%s", generatedByComment, typesStr)

//go:embed internal/metadata.go
var metadataTemplate string

// -----------------------------------------------------------------------------
// Data Structures
// -----------------------------------------------------------------------------

/*
BLOBPayload represents the top-level JSON payload from the MDS3 JWT. This payload matches the
“Metadata BLOB Payload” described in the FIDO Metadata Service v3.0 specification (cf. §3.1.6
“MetadataBLOBPayload” dictionary), although it is simplified to focus on the elements we need:

  - LegalHeader: A statement referencing usage acceptance
  - No: An incremental, monotonically increasing number identifying the MDS BLOB
  - NextUpdate: A date by which a new BLOB update should be published
  - Entries: A slice of Entry structures (from 'aaguids') describing various authenticator models
*/
type BLOBPayload struct {
	LegalHeader string          `json:"legalHeader"`
	No          int             `json:"no"`
	NextUpdate  string          `json:"nextUpdate"`
	Entries     []aaguids.Entry `json:"entries"`
}

type PassKeyJSONRecord struct {
	Name      string  `json:"name"`
	IconDark  *string `json:"icon_dark"`
	IconLight *string `json:"icon_light"`
}

/*
jwsHeader models the JWT header portion (for JWS) needed to parse the MDS3-signed JWT.

Typical fields:
  - Alg:  e.g. "RS256", "ES256", etc.
  - Typ:  typically "JWT"
  - X5c:  an array of base64-encoded certificates that chain back to a trusted root
*/
type jwsHeader struct {
	Alg string   `json:"alg"`
	Typ string   `json:"typ"`
	X5c []string `json:"x5c"`
}

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

// mapMetadataSignatureType is used for bridging JOSE alg strings like "RS256" to x509.SignatureAlgorithm values.
var mapMetadataSignatureType = map[string]x509.SignatureAlgorithm{
	"RS256": x509.SHA256WithRSA,
	"PS256": x509.SHA256WithRSAPSS,
	"ES256": x509.ECDSAWithSHA256,
	"RS384": x509.SHA384WithRSA,
	"PS384": x509.SHA384WithRSAPSS,
	"ES384": x509.ECDSAWithSHA384,
	"RS512": x509.SHA512WithRSA,
	"PS512": x509.SHA512WithRSAPSS,
	"ES512": x509.ECDSAWithSHA512,
}

// -----------------------------------------------------------------------------
// Main Program
// -----------------------------------------------------------------------------

/*
main is the entry point of this generator program. It:

 1. Fetches the JWT from the official MDS3 endpoint
 2. Parses and verifies the JWT (including x5c cert chain signature)
 3. Unmarshals the top-level JSON payload into a BLOBPayload
 4. Builds a map of [AAGUID → Entry]
 5. Writes out two files under the chosen directory:
    a. types.go (generated from embedded content)
    b. metadata.go (containing a static `metadata` map literal of AAGUID → Entry)
*/
func main() {
	outDir := flag.String("o", "internal/", "Output directory path (e.g. -o internal/)")
	flag.Parse()

	// Ensure the output directory exists.
	if err := os.MkdirAll(*outDir, 0o755); err != nil {
		panic(fmt.Errorf("failed to create output directory: %w", err))
	}

	ctx := context.Background()

	// 1. Fetch the JWT from the MDS3 well-known URL.
	jwtBytes, err := fetch(ctx, "https://mds3.fidoalliance.org/")
	if err != nil {
		panic(fmt.Errorf("fetching MDS3 JWT: %w", err))
	}

	passkeyAuthenticatorAaguidsBytes, err := fetch(ctx, "https://raw.githubusercontent.com/passkeydeveloper/passkey-authenticator-aaguids/refs/heads/main/aaguid.json")
	if err != nil {
		panic(fmt.Errorf("fetching MDS3 JWT: %w", err))
	}

	// 2. Parse and verify the JWT signature, returning the JSON payload portion.
	_, payloadBytes, err := parseAndVerifyJWT(jwtBytes)
	if err != nil {
		panic(fmt.Errorf("JWT parsing & verification failed: %w", err))
	}

	// 3. Decode the JSON payload into our BLOBPayload structure.
	var blob BLOBPayload
	if err := json.Unmarshal(payloadBytes, &blob); err != nil {
		panic(fmt.Errorf("cannot unmarshal MDS payload: %w", err))
	}

	var blobPassKey map[string]PassKeyJSONRecord
	if err := json.Unmarshal(passkeyAuthenticatorAaguidsBytes, &blobPassKey); err != nil {
		panic(fmt.Errorf("cannot unmarshal passkey-authenticator-aaguids JSON payload: %w", err))
	}

	// 4. Build a map of [AAGUID] → Entry. Skip entries without a valid AAGUID (e.g. for UAF).
	entriesMap := make(map[string]aaguids.Entry)
	for _, entry := range blob.Entries {
		if entry.AAGUID == "" {
			continue // skip if no AAGUID
		}
		if _, parseErr := uuid.Parse(entry.AAGUID); parseErr != nil {
			continue // skip invalid UUID
		}
		entriesMap[entry.AAGUID] = entry
	}

	for aaguid, entry := range blobPassKey {
		icon, iconDark := "", ""
		if entry.IconDark != nil {
			iconDark = *entry.IconDark
		}
		if entry.IconLight != nil {
			icon = *entry.IconLight
		}
		entriesMap[aaguid] = aaguids.Entry{
			AAGUID: aaguid,
			MetadataStatement: aaguids.MetadataStatement{
				AAGUID:      aaguid,
				Description: entry.Name,
				Icon:        icon,
				IconDark:    iconDark,
			},
		}
	}

	// 5) Prepare the output folder for writing types.go and metadata.go
	aaguidDir := path.Join(*outDir, "aaguids")
	if err := os.MkdirAll(aaguidDir, 0o755); err != nil {
		panic(fmt.Errorf("failed to create aaguids output folder: %w", err))
	}

	// 5a. Format and write the embedded types.go content
	typesFileContentFormatted, err := format.Source([]byte(typesFileContent))
	if err != nil {
		panic(fmt.Errorf("formatting types.go content: %w", err))
	}
	typesPath := filepath.Join(aaguidDir, "types.go")
	if err := os.WriteFile(typesPath, typesFileContentFormatted, 0o644); err != nil {
		panic(fmt.Errorf("writing types.go: %w", err))
	}

	// 5b) Create metadata.go with the static map literal for all AAGUIDs
	metadataLiteral := mapToGoLiteral(entriesMap)
	metadataFile := strings.Replace(
		metadataTemplate,
		"map[string]Entry",
		fmt.Sprintf("= %s", metadataLiteral),
		1,
	)

	metadataFileFormatted, err := format.Source([]byte(metadataFile))
	if err != nil {
		panic(fmt.Errorf("formatting metadata.go content: %w", err))
	}
	metadataPath := filepath.Join(aaguidDir, "metadata.go")
	if err := os.WriteFile(metadataPath, metadataFileFormatted, 0o644); err != nil {
		panic(fmt.Errorf("writing metadata.go: %w", err))
	}
}

// -----------------------------------------------------------------------------
// Network & JWT Parsing
// -----------------------------------------------------------------------------

/*
fetch downloads the raw JWT bytes from the specified url. It checks for 2xx responses
and returns an error otherwise.

This code expects the official MDS3 endpoint, typically "https://mds3.fidoalliance.org/".
*/
func fetch(ctx context.Context, url string) ([]byte, error) {
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return nil, fmt.Errorf("creating HTTP request: %w", err)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("fetching URL %q: %w", url, err)
	}
	defer resp.Body.Close()

	if resp.StatusCode < http.StatusOK || resp.StatusCode > 299 {
		return nil, fmt.Errorf("non-2xx response: %s", resp.Status)
	}
	return io.ReadAll(resp.Body)
}

/*
parseAndVerifyJWT splits the given JWT into header, payload, and signature. It then:

  - Decodes the header (which must have x5c certificates)
  - Verifies the certificate chain (we rely on standard PKI validation)
  - Uses the "alg" field to map to a x509.SignatureAlgorithm
  - Verifies the signature across the "header.payload" with the leaf cert

Returns:
  - headerDecoded: The decoded header bytes
  - payloadDecoded: The decoded payload bytes
  - err: Any error from decoding or verification
*/
func parseAndVerifyJWT(jwtBytes []byte) (headerDecoded, payloadDecoded []byte, err error) {
	parts := strings.Split(string(jwtBytes), ".")
	if len(parts) != 3 {
		return nil, nil, errors.New("invalid JWT: must have 3 dot-separated parts")
	}

	headerPart, err := base64RawURIDecode(parts[0])
	if err != nil {
		return nil, nil, fmt.Errorf("decode header part: %w", err)
	}
	payloadPart, err := base64RawURIDecode(parts[1])
	if err != nil {
		return nil, nil, fmt.Errorf("decode payload part: %w", err)
	}
	signaturePart, err := base64RawURIDecode(parts[2])
	if err != nil {
		return nil, nil, fmt.Errorf("decode signature part: %w", err)
	}

	// Unmarshal the header JSON, expecting a jwsHeader struct
	var hdr jwsHeader
	if unmarshalErr := json.Unmarshal(headerPart, &hdr); unmarshalErr != nil {
		return nil, nil, fmt.Errorf("unmarshal JWT header: %w", unmarshalErr)
	}
	if len(hdr.X5c) == 0 {
		return nil, nil, errors.New("no x5c field present in header")
	}

	// Convert each base64 PEM entry in X5c to an x509.Certificate
	certs := make([]*x509.Certificate, 0, len(hdr.X5c))
	for i, c := range hdr.X5c {
		der, decErr := base64.StdEncoding.DecodeString(c)
		if decErr != nil {
			return nil, nil, fmt.Errorf("decode x5c[%d]: %w", i, decErr)
		}
		cert, parseErr := x509.ParseCertificate(der)
		if parseErr != nil {
			return nil, nil, fmt.Errorf("parse x5c[%d]: %w", i, parseErr)
		}
		certs = append(certs, cert)
	}

	leafCert := certs[0]
	intermediates := x509.NewCertPool()
	for _, ic := range certs[1:] {
		intermediates.AddCert(ic)
	}

	// Perform minimal chain validation.
	if _, verifyErr := leafCert.Verify(x509.VerifyOptions{
		Intermediates: intermediates,
	}); verifyErr != nil {
		return nil, nil, fmt.Errorf("certificate chain verify fail: %w", verifyErr)
	}

	// Map the JOSE alg string to x509 signature algorithm
	sigAlg, ok := mapMetadataSignatureType[hdr.Alg]
	if !ok {
		return nil, nil, fmt.Errorf("unrecognized signature alg: %s", hdr.Alg)
	}

	// The actual signing input is "header.base64 + '.' + payload.base64"
	signingInput := []byte(parts[0] + "." + parts[1])
	if sigErr := leafCert.CheckSignature(sigAlg, signingInput, signaturePart); sigErr != nil {
		return nil, nil, fmt.Errorf("JWT signature check failed: %w", sigErr)
	}

	return headerPart, payloadPart, nil
}

// -----------------------------------------------------------------------------
// Encoding & Utility
// -----------------------------------------------------------------------------

/*
base64RawURIDecode performs a Base64-URL decode with or without padding. It transforms
'-' → '+' and '_' → '/', then applies padding logic if needed, and finally decodes.
*/
func base64RawURIDecode(s string) ([]byte, error) {
	s = strings.ReplaceAll(s, "-", "+")
	s = strings.ReplaceAll(s, "_", "/")
	switch len(s) % 4 {
	case 2:
		s += "=="
	case 3:
		s += "="
	}
	return base64.StdEncoding.DecodeString(s)
}

// -----------------------------------------------------------------------------
// Mapping a map[string]Entry to a Go Literal
// -----------------------------------------------------------------------------

/*
mapToGoLiteral transforms a map[string]Entry into a valid Go literal of the form:

	map[string]Entry{
	  "uuid1": { ... },
	  "uuid2": { ... },
	}

The result is intended for writing static source code (metadata.go).
*/
func mapToGoLiteral(m map[string]aaguids.Entry) string {
	if len(m) == 0 {
		return "map[string]Entry{}"
	}

	// Sort keys for stable output
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	var b strings.Builder
	b.WriteString("map[string]Entry{\n")
	for _, k := range keys {
		val := m[k]
		b.WriteString(fmt.Sprintf("  %q: ", k))
		b.WriteString(entryToLiteral(val))
		b.WriteString(",\n")
	}
	b.WriteString("}")
	return b.String()
}

/*
entryToLiteral converts a single aaguids.Entry struct to a Go struct literal. This helps produce:

	Entry{
	  AAGUID: "...",
	  ...,
	  StatusReports: []StatusReport{...},
	  ...
	}

via reflection. The reflection code is contained in structToLiteral(...) and valueToLiteral(...).
*/
func entryToLiteral(e aaguids.Entry) string {
	return structToLiteral("Entry", e)
}

/*
structToLiteral converts a struct into a Go literal of the form:

	TypeName{
	  FieldName: <literal>,
	  FieldName: <literal>,
	}

It recurses through slices, maps, pointers, etc. by delegating to valueToLiteral.
*/
func structToLiteral(typeName string, v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.Kind() != reflect.Struct {
		return valueToLiteral(v)
	}

	var b strings.Builder
	b.WriteString(typeName + "{\n")

	rt := rv.Type()
	for i := 0; i < rt.NumField(); i++ {
		field := rt.Field(i)
		fieldName := field.Name
		if !field.IsExported() {
			continue // skip unexported fields
		}
		fieldValue := rv.Field(i).Interface()
		goValueLit := valueToLiteral(fieldValue)
		b.WriteString("  " + fieldName + ": " + goValueLit + ",\n")
	}

	b.WriteString("}")
	return b.String()
}

/*
valueToLiteral produces a Go literal for the provided value. It handles strings, slices, maps, structs,
pointers, numeric types, etc. The result is intended to form valid Go source code.

For instance:
  - slice → []SomeType{ ... }
  - map → map[KeyType]ValType{ "k": "v", ... }
  - pointer → a typed pointer expression or "nil"
*/
func valueToLiteral(val interface{}) string {
	if val == nil {
		return "nil"
	}
	rv := reflect.ValueOf(val)

	switch rv.Kind() {
	case reflect.Ptr:
		if rv.IsNil() {
			return "nil"
		}
		// Generate the Go literal for the underlying value
		underlying := valueToLiteral(rv.Elem().Interface())

		// Then wrap it in goPtr(...)
		return fmt.Sprintf("goPtr(%s(%s))", rv.Elem().Type().String(), underlying)
	case reflect.String:
		if reflect.TypeOf(val).String() == "aaguids.AuthenticatorStatus" {
			s := rv.Convert(reflect.TypeFor[aaguids.AuthenticatorStatus]()).Interface().(aaguids.AuthenticatorStatus)
			return fmt.Sprintf("%v", s)
		}
		if rv.Type().ConvertibleTo(reflect.TypeOf("")) {
			s := rv.Convert(reflect.TypeOf("")).Interface().(string)
			return fmt.Sprintf("%q", s)
		}

		return fmt.Sprintf("%q", strings.Replace(rv.String(), "aaguids.", "", 1))

	case reflect.Slice:
		if rv.IsNil() {
			return "nil"
		}
		sliceType := rv.Type().String()
		sliceType = strings.ReplaceAll(sliceType, "aaguids.", "")
		var sb strings.Builder
		sb.WriteString(sliceType)
		sb.WriteString("{")
		for i := 0; i < rv.Len(); i++ {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(valueToLiteral(rv.Index(i).Interface()))
		}
		sb.WriteString("}")
		return sb.String()

	case reflect.Map:
		if rv.IsNil() {
			return "nil"
		}
		mapType := rv.Type().String()
		mapType = strings.ReplaceAll(mapType, "aaguids.", "")
		var sb strings.Builder
		sb.WriteString(mapType + "{")
		keys := rv.MapKeys()
		if len(keys) > 0 && keys[0].Kind() == reflect.String {
			sort.Slice(keys, func(i, j int) bool {
				return keys[i].String() < keys[j].String()
			})
		}
		for i, mk := range keys {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(valueToLiteral(mk.Interface()))
			sb.WriteString(": ")
			sb.WriteString(valueToLiteral(rv.MapIndex(mk).Interface()))
		}
		sb.WriteString("}")
		return sb.String()

	case reflect.Struct:
		tName := rv.Type().Name()
		if tName == "" {
			tName = rv.Type().String()
		}
		return structToLiteral(tName, val)

	case reflect.Bool:
		return fmt.Sprintf("%v", rv.Bool())

	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return fmt.Sprintf("%d", rv.Int())

	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return fmt.Sprintf("%d", rv.Uint())

	case reflect.Float32, reflect.Float64:
		return fmt.Sprintf("%g", rv.Float())

	default:
		// fallback
		return fmt.Sprintf("%#v", val)
	}
}
